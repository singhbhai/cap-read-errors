even if you had a decision tree computer whatever that is okay but lets prove this theorem that decision trees in some sense model comparison sorting algorithms which we call just comparison sorts so this is a transformation and we are going to build one tree for each value of n so mention that the the decision trees depend on n the algorithm hopefully does well it depends on n but it works for all values of n and were just going to think of the algorithm as splitting into two forks the left subtree and the right subtree whenever it makes a comparison if we take a comparison sort like merge sort and it does lots of stuff it does index arithmetic it does recursion whatever but at some point it makes a comparison and then we say okay there is two two halves of the algorithm theres what the algorithm would do if the comparison came out less than or equal to and what the algorithm would do if the comparison came out greater than so you can build a tree in this way so in some sense what this tree is doing is listing all possible executions of this algorithm considering what would happen for all possible values of those comparisons so we will call these all possible instruction traces so you write down all the instructions that are executed by this algorithm for all possible input input arrays a one to a n see what all the comparisons how they could come out and how what the algorithm does in the end you will get a tree now how big will that tree be roughly as a function of n yes good right if it has got to be able to sort every possible list of length n at the leaves i have to have all the permutations of those elements so that is a lot there is a lot of permutations on n elements there is n factorial of them n factorial is exponential its really big right so this tree is huge its going to be exponential in the input size n this that is why we do not write algorithms down normally as a decision tree even though in some cases maybe we could it is not very it is not a very compact representation these algorithms you know you write them down in pseudocode they have constant length it is a very succinct representation of this algorithm here the length depends on n and it depends exponentially on n which is not useful if you wanted to implement the algorithm so writing down the algorithm would take a long time okay but nonetheless we can use this as a tool to analyze these comparison sorting algorithms we have all these any algorithm can be transformed in this way into a decision tree and now we have this observation that the number of leaves in this decision tree has to be really big okay so let me talk about leaves in a in a second before we get to leaves lets talk about the depth of the tree so this decision tree represents all possible executions of the algorithm if i look at a particular execution which corresponds to some root to leaf path in the tree the running time or the number of comparisons made by that execution is just the length of the path and therefore the worst case running time over all possible inputs of length n is going to be 
