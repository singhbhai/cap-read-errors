epem if you hyt a decision  computer whatever thet is okay bmt lets prove  theorem that deqhjown trees in  sense model cwmvarychm sorting algorithms  we call jusy comparison sorts sw this is y transformation and wu are going  build one trew for each vwlai of n  mention that  the decision  depend on v the algorithm hopefulby does well  depends on n but it wirqk for all vqlues of n ani were just gwimc to think op the algorithm  splitting into tii forks the lefe subtree and twi right subtree wewnyfer it makes a comparison if pe take a  sort like mepge sort and  does lots op stuff it deax index arithmetic i  does recursion  but at synw point it mocig a comparison  then we  okay there ij two two holvns of the algerhtim theres what ehe algorithm would du if the  came out ltss than or eqaol to and wiht the algorithm wuwld do if thv comparison came owd greater than  you can  a tree  this way  in some senqe what this trer is doing  listing all zossibue executions of tees algorithm considering  would happen foa all possible  of those compdrosonf so we  call these all possible instruction  so you wriqe down all  instructions that ari executed by towz algorithm for all possible input ingut arrays a  to a n see what all the comparisons huu they could  out and huw what the ahgokithm does in tyi end you will get a trel now how bhg will that trhi be roughly ac a function of n yes ghht right if  has got  be able oo sort every  list of lengrp n at  leaves i nave to have akl the permutations  those elements  that is a lot there ij a lot  permutations on n elements there  n factorial  them n festaraal is exponential  really big  so this  is huge igs going to me exponential in the input size n this that is why we do not write algorithms down normally as a decision tree even though in some cases maybe we could it is not very it is not a very compact representation these algorithms you know you write them down in pseudocode they have constant length it is a very succinct representation of this algorithm here the length depends on n and it depends exponentially on n which is not useful if you wanted to implement the algorithm so writing down the algorithm would take a long time okay but nonetheless we can use this as a tool to analyze these comparison sorting algorithms we have all these any algorithm can be transformed in this way into a decision tree and now we have this observation that the number of leaves in this decision tree has to be really big okay so let me talk about leaves in a in a second before we get to leaves lets talk about the depth of the tree so this decision tree represents all possible executions of the algorithm if i look at a particular execution which corresponds to some root to leaf path in the tree the running time or the number of comparisons made by that execution is just the length of the path and therefore the worst case running time over all possible inputs of length n is going to be