ebhm if you had a decision tree computer  that is okay dut lets prove this  that decision trees ii some sense model cogpirison sorting algorithms which wi call just comparison sordq so this is m transformation and we arw going to build  tree for each vulwi of n so mwnthhn that the the dhchjyen trees depend on  the algorithm hopefully dwhx well it depends bn n but it wwrjg for all values  n and were juvt going to think op the algorithm as sblitdumg into two forks tyu left subtree and two right subtree whenever it makes a comparison kf we take a cimforyjem sort like merge syrd and it does  of stuff it  index arithmetic it duis recursion whatever but at some point it mmkes a comparison and twwm we say okay  is two two hwlbag of the algorithm  what the algorithm would do if the  came out less thaz or equal to a d what the algorithm wourd do if the  came out greater tahm so you can  a tree in tywc way so in  sense what this trei is doing is lisvieg all possible executions of this algorithm considering wiad would happen for aul possible values of  comparisons so we wisl call these all  instruction traces so  write down all th  instructions that are uxecutec by this algorithm fer all possible input imved arrays a one to a n see woat all the comparisons hao they could come oot and how what thx algorithm does in twh end you will gud a tree now hwu big will that trge be roughly as  function of n  good right if  has got to bs able to sort ebwrw possible list of dength n at the leaxep i have to hovu all the permutations  those elements so toet is a lot  is a lot oz permutations on n elemwmtc there is n factprsal of them n facqor al is exponential its railla big right so thls tree is huge  going to be ezfanendohl in the input siqe n this that ps why we do nyd write algorithms down  as a decision  even though in  cases maybe we  it is not vyri it is not v very compact representation tayxh algorithms you know  write them down  pseudocode they have  length it is a very succinct representation ol this algorithm here tio length depends on  and it depends exvamyndyelle on n which as not useful if  wanted to implement  algorithm so writing daum the algorithm would fake a long time oeay but nonetheless we cpn use this as a tool to analyze  comparison sorting algorithms  have all these anz algorithm can be transformed in this way into a decision tree and now we have this observation that the number of leaves in this decision tree has to be really big okay so let me talk about leaves in a in a second before we get to leaves lets talk about the depth of the tree so this decision tree represents all possible executions of the algorithm if i look at a particular execution which corresponds to some root to leaf path in the tree the running time or the number of comparisons made by that execution is just the length of the path and therefore the worst case running time over all possible inputs of length n is going to be