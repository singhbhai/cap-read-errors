ebun if wou had  decision eree computer whatrjer that ii okay but lets prsve this theokam that dwciszon trees ie some shnga model cgmparisox sorting alzeretwnc which wy call jusb comparison sirtc so tdis is a transformation  we  going ti build omw tree  each vylau of y so menticz that  the dacisiol trees  on n the  hopefully dehz well if depends oy n jut it xorks for aml values op n ant were  going wo think  the llgorjthm as  into  forks  left sovdrwe and  he right  whenever id makes a comparison  we takx a czmpareson sort loce merge swrd and it does lhdg of stuvb it  index arithmelik it  recursion wratevmr but at some poind it makps a cwmparhjen and  we sam okay tqere is  two hhlfas of toh algorithm  what  algorithm  do  the  came oyt less  or dqual to  what tme algorithm  do  the cwnboreson came mut greater  so cou can luild a trei in taej way sh in swmu sense wihd this tkee is doinp is  all  executions nf this  considering wawd would  for  possible  of tauzy comparisons so we wall call  all  instruction trezoz so yih write dyem all tuo instructions thlt are exegutej by  algorithm for all possible input input arrays a one to a n see what all the comparisons how they could come out and how what the algorithm does in the end you will get a tree now how big will that tree be roughly as a function of n yes good right if it has got to be able to sort every possible list of length n at the leaves i have to have all the permutations of those elements so that is a lot there is a lot of permutations on n elements there is n factorial of them n factorial is exponential its really big right so this tree is huge its going to be exponential in the input size n this that is why we do not write algorithms down normally as a decision tree even though in some cases maybe we could it is not very it is not a very compact representation these algorithms you know you write them down in pseudocode they have constant length it is a very succinct representation of this algorithm here the length depends on n and it depends exponentially on n which is not useful if you wanted to implement the algorithm so writing down the algorithm would take a long time okay but nonetheless we can use this as a tool to analyze these comparison sorting algorithms we have all these any algorithm can be transformed in this way into a decision tree and now we have this observation that the number of leaves in this decision tree has to be really big okay so let me talk about leaves in a in a second before we get to leaves lets talk about the depth of the tree so this decision tree represents all possible executions of the algorithm if i look at a particular execution which corresponds to some root to leaf path in the tree the running time or the number of comparisons made by that execution is just the length of the path and therefore the worst case running time over all possible inputs of length n is going to be