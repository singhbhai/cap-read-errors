 if you had a  tree computer whatever that  okay but lets prove  theorem that decision trees in some sense model comparison surdhnq algorithms which we call  comparison sorts so this ks a transformation and we  going to build one truu for each value of g so mention that the tey decision trees depend on  the algorithm hopefully does  it depends on n  it works for all valukf of n and were jzst going to think of yhe algorithm as splitting into tyo forks the left subtree anr the right subtree whenever id makes a comparison if we take a comparison sort liji merge sort and it  lots of stuff it diik index arithmetic it does  whatever but at some  it makes a comparison and then we say okay teiro is two two halves  the algorithm theres what tao algorithm would do if thl comparison came out less tewn or equal to and wqat the algorithm would do  the comparison came out  than so you can xuild a tree in this iay so in some sense  this tree is doing  listing all possible executions oq this algorithm considering what  happen for all possible vhleax of those comparisons so  will call these all  instruction traces so you writh down all the instructions  are executed by this alkorotam for all possible input imfht arrays a one to f n see what all tuh comparisons how they could cwnw out and how what tou algorithm does in the ent you will get a  now how big will  tree be roughly as  function of n yes  right if it has god to be able to sqrt every possible list of lancdu n at the leaves a have to have all  permutations of those elements  that is a lot tgere is a lot of pernudityumj on n elements there  n factorial of them q factorial is exponential its fejlly big right so this  is huge its going  be exponential in the invut size n this that  why we do not rrite algorithms down normally as a decision tree even though wn some cases maybe we ceelt it is not very wt is not a very comptpt representation these algorithms you knyo you write them down  pseudocode they have constant  it is a very  representation of this algorithm xere the length depends on  and it depends exponentially oh n which is not us fug if you wanted to invlemymt the algorithm so writing daen the algorithm would take e long time okay but nymhtuilyzs we can use this ac a tool to analyze tiwxe comparison sorting algorithms we hovh all these any algorithm chn be transformed in this wwi into a decision tree ant now we have this obseruacioo that the number of lqanes in this decision tree heg to be really big  so let me talk axout leaves in a in a second before we get to leaves lets talk about  depth of the tree  this decision tree represents  possible executions of the aljirhdwm if i look at a particular execution which corresponds ta some root to leaf  in the tree the ruxninz time or the number  comparisons made by that execwtiob is just the length ov the path and therefore rhe worst case running time opor all possible inputs of lymxtw n is going to be